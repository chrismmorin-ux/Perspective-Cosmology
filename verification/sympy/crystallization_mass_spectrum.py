#!/usr/bin/env python3
"""
Crystallization Mass Spectrum: What mass scales does the tilt potential predict?

KEY FINDINGS:
1. Tilt field mass m_tilt ~ 2*sqrt(2)*alpha*M_Pl ~ 2.5e17 GeV (near GUT scale)
2. The tilt mass hierarchy: m_tilt/M_Pl = 2*sqrt(2)*alpha ~ 0.021
3. Crystallization complete mass: m_cryst = mu*M_Pl ~ 14.8 M_Pl (Planck scale)
4. Off-diagonal mass (decoherence): same as m_tilt (drives collapse)

This script explores:
- Mass scales from the tilt potential W(eps, phi)
- Mass hierarchy generated by the framework
- Connection to known energy scales
- The phi-dependent mass spectrum

Created: Session 132
Status: EXPLORATION
"""

from sympy import *

# ==============================================================================
# FRAMEWORK CONSTANTS
# ==============================================================================

R, C_dim, H, O = 1, 2, 4, 8
Im_H, Im_O = 3, 7
n_d = 4
n_c = 11
alpha_inv = n_d**2 + n_c**2  # 137
alpha = Rational(1, alpha_inv)
mu2 = Rational((C_dim + H) * H**4, Im_O)  # 1536/7

print("="*70)
print("CRYSTALLIZATION MASS SPECTRUM")
print("="*70)

# ==============================================================================
# PART 1: MASS SCALES FROM THE TILT POTENTIAL
# ==============================================================================

print("\n" + "="*70)
print("PART 1: MASS SCALES FROM W(eps, phi)")
print("="*70)

# The tilt potential (best candidate from ab_derivation):
# W(eps, phi) = -a*g(phi)*eps^2 + b*eps^4
# with a = 2*alpha^2*M_Pl^4, b = M_Pl^4, g(phi) = 1 - phi^2/mu^2

# Equilibrium: eps* = alpha * sqrt(g(phi))

# Masses at the equilibrium eps*:

# 1. Radial mass (fluctuations in |eps| around eps*)
# m_radial^2 = d^2W/d|eps|^2 at eps*
# = -2a*g + 12b*eps*^2
# = -2a*g + 12b*(a*g/(2b))
# = -2a*g + 6a*g = 4a*g
# m_radial = 2*sqrt(a*g) = 2*sqrt(2)*alpha*sqrt(g)*M_Pl^2... wait

# Let me be more careful with dimensions.
# W has units [mass^4] (energy density)
# eps is dimensionless
# d^2W/deps^2 has units [mass^4]
# The field eps doesn't have canonical normalization!

# To get a mass, we need the kinetic term:
# L_eps = (1/2)*f^2*(d eps)^2 - W(eps)
# where f is the "decay constant" of the tilt field with units [mass^2]

# With canonical normalization: chi = f*eps, the Lagrangian becomes
# L = (1/2)*(d chi)^2 - W(chi/f)
# and m^2 = (1/f^2) * d^2W/deps^2

# What is f?
# From Layer 0: eps_ij = <pi(b_i), pi(b_j)> - delta_ij
# This is a dimensionless geometric quantity
# The kinetic term L_eps = (1/2)*f^2*Tr[(d eps)^2] requires f ~ M_Pl^2
# (to get canonical kinetic energy in 4D)

# Natural choice: f = M_Pl^2 (Planck scale normalization)
# This gives: chi = M_Pl^2 * eps (canonical field)
# And: m^2 = (1/M_Pl^4) * d^2W/deps^2

print("\nMass from the tilt potential:")
print("  W(eps) = -a*eps^2 + b*eps^4")
print("  d^2W/deps^2 at eps* = 4*a*g(phi)")
print("  With normalization f = M_Pl^2:")
print("  m_tilt^2 = (1/f^2) * d^2W/deps^2 = 4*a*g / M_Pl^4")

# With a = 2*alpha^2*M_Pl^4:
# m_tilt^2 = 4*2*alpha^2*M_Pl^4*g / M_Pl^4 = 8*alpha^2*g
# m_tilt = 2*sqrt(2)*alpha*sqrt(g) * M_Pl

print("\n  With a = 2*alpha^2*M_Pl^4 and g = g(phi):")
print(f"  m_tilt^2 = 8*alpha^2*g(phi) * M_Pl^2")
print(f"  m_tilt = 2*sqrt(2)*alpha*sqrt(g) * M_Pl")

# At phi = 0 (pre-crystallization, g = 1):
m_tilt_0 = 2*sqrt(2)*alpha  # in M_Pl
print(f"\n  At phi = 0 (g = 1):")
print(f"    m_tilt = 2*sqrt(2)/137 * M_Pl = {float(m_tilt_0):.6f} M_Pl")
print(f"           = {float(m_tilt_0) * 1.22e19:.2e} GeV")

# At CMB epoch (phi = mu/sqrt(6), g = 5/6):
m_tilt_CMB = 2*sqrt(2)*alpha*sqrt(Rational(5,6))  # in M_Pl
print(f"\n  At CMB epoch (g = 5/6):")
print(f"    m_tilt = 2*sqrt(2)*alpha*sqrt(5/6) * M_Pl = {float(m_tilt_CMB):.6f} M_Pl")
print(f"           = {float(m_tilt_CMB) * 1.22e19:.2e} GeV")

# At crystallization complete (phi = mu, g = 0):
print(f"\n  At crystallization complete (g = 0):")
print(f"    m_tilt = 0 (tilt field becomes massless!)")
print(f"    This is the critical point where the Mexican hat vanishes")

# ==============================================================================
# PART 2: MASS HIERARCHY
# ==============================================================================

print("\n" + "="*70)
print("PART 2: MASS HIERARCHY FROM FRAMEWORK")
print("="*70)

# The framework generates several mass scales:
scales = {}

# 1. Planck mass (fundamental scale)
scales['M_Pl'] = (1, 'Planck mass')

# 2. Tilt field mass
scales['m_tilt'] = (float(m_tilt_0), 'Tilt field mass')

# 3. Hilltop scale
mu_val = float(sqrt(mu2))
scales['mu*M_Pl'] = (mu_val, 'Hilltop scale mu')

# 4. Hubble scale during inflation
# H_inf ~ sqrt(V_0/3)/M_Pl ~ alpha^2/sqrt(3) (if V_0 ~ alpha^4*M_Pl^4)
H_inf = float(alpha**2 / sqrt(3))
scales['H_inf'] = (H_inf, 'Hubble during inflation')

# 5. Critical BH mass
M_crit = Rational(alpha_inv, 2)
scales['M_crit'] = (float(M_crit), 'Critical BH mass (in M_Pl)')

# 6. eps* in energy units: eps* * M_Pl^2 / f... this is just eps* = alpha
# The eps field excitation energy is m_tilt (the mass)

# 7. Mexican hat depth energy density^(1/4)
# W(eps*) = -alpha^4*M_Pl^4
# Fourth root: alpha*M_Pl
W_depth_scale = float(alpha)
scales['W^(1/4)'] = (W_depth_scale, 'Mexican hat depth scale')

# Print sorted
print(f"\nMass scales in Planck units:")
print(f"{'Scale':<15} {'M/M_Pl':<15} {'GeV':<15} {'Name'}")
print("-"*65)

for name, (val, desc) in sorted(scales.items(), key=lambda x: -x[1][0]):
    print(f"  {name:<13} {val:<15.6f} {val*1.22e19:<15.2e} {desc}")

# Ratios
print(f"\nKey ratios:")
print(f"  mu / 1 = {mu_val:.2f} (hilltop is super-Planckian)")
print(f"  M_crit / M_Pl = {float(M_crit):.1f}")
print(f"  m_tilt / M_Pl = {float(m_tilt_0):.6f} = 2*sqrt(2)*alpha")
print(f"  H_inf / M_Pl = {H_inf:.6f} = alpha^2/sqrt(3)")
print(f"  m_tilt / H_inf = {float(m_tilt_0)/H_inf:.0f} (tilt is stiff during inflation)")

# ==============================================================================
# PART 3: phi-DEPENDENT MASS EVOLUTION
# ==============================================================================

print("\n" + "="*70)
print("PART 3: phi-DEPENDENT MASS EVOLUTION")
print("="*70)

print("""
As crystallization proceeds (phi: 0 -> mu), all masses evolve:

  m_tilt(phi) = 2*sqrt(2)*alpha*sqrt(g(phi)) * M_Pl
  eps*(phi) = alpha * sqrt(g(phi))
  W_depth(phi) = -alpha^4 * g(phi)^2 * M_Pl^4

The tilt field mass DECREASES as phi grows:
  - This means the Mexican hat becomes shallower
  - Particles become "lighter" in tilt units
  - At phi = mu: m_tilt = 0, all structure dissolves
""")

# Table of mass evolution
phi_fracs = [0, Rational(1,4), Rational(1,2), Rational(3,4), Rational(9,10), 1]
print(f"{'phi/mu':<10} {'g(phi)':<10} {'m_tilt/m_0':<15} {'eps*/alpha':<15} {'|W|/|W_0|'}")
print("-"*60)

for frac in phi_fracs:
    g = 1 - frac**2
    m_ratio = float(sqrt(g))
    eps_ratio = float(sqrt(g))
    W_ratio = float(g**2)
    print(f"  {float(frac):<8.2f} {float(g):<10.4f} {m_ratio:<15.4f} {eps_ratio:<15.4f} {W_ratio:.4f}")

# ==============================================================================
# PART 4: WHAT IS m_tilt PHYSICALLY?
# ==============================================================================

print("\n" + "="*70)
print("PART 4: PHYSICAL INTERPRETATION OF m_tilt")
print("="*70)

m_tilt_GeV = float(m_tilt_0) * 1.22e19
print(f"\nm_tilt = 2*sqrt(2)*alpha*M_Pl = {m_tilt_GeV:.2e} GeV")
print(f"\nComparison to known scales:")
print(f"  M_Pl     = 1.22e+19 GeV  (Planck)")
print(f"  M_GUT    ~ 2e+16 GeV     (Grand unification)")
print(f"  m_tilt   = {m_tilt_GeV:.2e} GeV")
print(f"  m_string ~ 1e+17 GeV     (String scale, typical)")
print(f"  M_EW     ~ 246 GeV       (Electroweak)")

print(f"\n  m_tilt / M_GUT ~ {m_tilt_GeV / 2e16:.0f} (about 10x GUT scale)")
print(f"  m_tilt is between GUT and Planck, near the string scale")

print(f"""
INTERPRETATION:

m_tilt = 2*sqrt(2)/137 * M_Pl represents the mass of "tilt excitations"
-- fluctuations of the local unorthogonality around its equilibrium.

This is:
  - TOO HEAVY to produce in any experiment
  - Light enough to be sub-Planckian (m_tilt << M_Pl)
  - Near the scale where new physics is expected (GUT/string)
  - The scale at which the "defect" has its own dynamics

In particle physics terms, this is the mass of the "perspective boson"
-- the quantum of the tilt field. It's a super-heavy particle that
mediates the crystallization force.

Note: This mass is for the RADIAL mode (fluctuations in |eps| around eps*).
The ANGULAR modes (rotations of the eigenvector basis) may be lighter or
even massless (Goldstone bosons of the broken rotation symmetry).
""")

# ==============================================================================
# PART 5: GOLDSTONE MODES
# ==============================================================================

print("="*70)
print("PART 5: GOLDSTONE MODES FROM TILT SYMMETRY BREAKING")
print("="*70)

# The tilt matrix eps_ij lives in Herm(n_d) which has n_d^2 = 16 dimensions
# When eps picks a specific direction (eigenstate), the symmetry
# U(n_d) is broken to U(1)^n_d (phases of each eigenvalue)

# Number of broken generators:
dim_U_nd = n_d**2  # dim U(n_d) = n_d^2
dim_residual = n_d  # dim U(1)^n_d = n_d (one phase per eigenvalue)
n_goldstone = dim_U_nd - dim_residual

print(f"\nSymmetry breaking: U({n_d}) -> U(1)^{n_d}")
print(f"  dim U({n_d}) = {dim_U_nd}")
print(f"  dim U(1)^{n_d} = {dim_residual}")
print(f"  Number of Goldstone modes = {n_goldstone}")

# These 12 Goldstone modes are the "angular" excitations
# They correspond to rotations of the eigenvector basis

print(f"\n  {n_goldstone} Goldstone modes = rotations of eigenvector basis")
print(f"  These should be MASSLESS (exact Goldstones)")
print(f"  Or PSEUDO-Goldstone (if symmetry is only approximate)")

# Check: do the 12 Goldstone modes relate to known particles?
print(f"\n  12 = dim(SU(2) x SU(3)) - 1 = 3 + 8 = 11... no, that's 11")
print(f"  12 = dim(SU(2) x U(1)) + dim(SU(3)) = 4 + 8 = 12!")
print(f"  Wait: dim(SU(2)) = 3, dim(U(1)) = 1, dim(SU(3)) = 8")
print(f"  3 + 1 + 8 = 12")

print(f"""
REMARKABLE COINCIDENCE?

The 12 Goldstone modes from U(4) -> U(1)^4 breaking equals:
  dim(SU(2)) + dim(U(1)) + dim(SU(3)) = 3 + 1 + 8 = 12

This is the dimension of the Standard Model gauge group
  SU(3)_color x SU(2)_weak x U(1)_Y!

If these Goldstone modes ARE the gauge bosons:
  - 8 gluons from SU(3) rotations of the eigenvector basis
  - 3 W bosons from SU(2) rotations
  - 1 B boson from U(1) rotation

But this is [SPECULATION]: the connection between tilt eigenvector
rotations and gauge symmetries needs rigorous derivation.
""")

# Verify: dim(SU(n)) = n^2 - 1
# For the full unitary group: dim(U(n)) = n^2
# Residual symmetry U(1)^n has dim n
# Goldstone count: n^2 - n = n(n-1)
# For n = 4: 4*3 = 12

n_goldstone_formula = n_d * (n_d - 1)
print(f"  Goldstone count = n_d*(n_d-1) = {n_d}*{n_d-1} = {n_goldstone_formula}")
print(f"  = {n_goldstone_formula}")

# Also: n_d*(n_d-1) = 4*3 = 12 = C_dim * (n_d+C_dim) = 2*6 = 12
# Multiple framework expressions for 12
print(f"\n  Framework expressions for 12:")
print(f"  n_d*(n_d-1) = {n_d*(n_d-1)}")
print(f"  C*(H+C) = {C_dim}*{H+C_dim} = {C_dim*(H+C_dim)}")
print(f"  Im_H * n_d = {Im_H}*{n_d} = {Im_H*n_d}")
print(f"  C_dim * (C_dim+H) = {C_dim}*{C_dim+H} = {C_dim*(C_dim+H)}")

# ==============================================================================
# PART 6: THE TOTAL BOSON COUNT
# ==============================================================================

print("\n" + "="*70)
print("PART 6: TOTAL BOSON COUNTING")
print("="*70)

print(f"""
From the tilt potential, the spectrum consists of:

MASSIVE MODES:
  - {n_d} radial modes (fluctuations of eigenvalues lambda_k)
    Mass: m_tilt = 2*sqrt(2)*alpha*M_Pl ~ 2.5e17 GeV each
    These are SUPER-HEAVY

MASSLESS MODES (Goldstone):
  - {n_goldstone_formula} angular modes (rotations of eigenvectors)
    Mass: 0 (exact Goldstone) or small (pseudo-Goldstone)
    These could be gauge bosons

TOTAL: {n_d} + {n_goldstone_formula} = {n_d + n_goldstone_formula} = n_d^2 = {n_d**2}

Note: The total {n_d**2} modes fill dim(Herm(n_d)) = {n_d**2}
as they should -- every degree of freedom is accounted for.

If the 12 Goldstone modes = gauge bosons:
  Then {n_d} = 4 massive modes are "Higgs-like" (radial modes)
  But 4 radial modes != 1 Higgs boson
  Unless 3 are "eaten" by gauge bosons (Higgs mechanism)
  leaving 1 physical Higgs and 3 massive gauge bosons

COUNTING CHECK:
  Start: 16 modes total
  12 Goldstone -> 12 gauge bosons
  4 radial -> 3 eaten (give mass to W+, W-, Z) + 1 physical Higgs?

But this is SU(3)xSU(2)xU(1) not SU(2)xU(1), so the eaten bosons
would be W+, W-, Z (3 from SU(2)xU(1)) and the 8 gluons stay massless.
That would eat 3 of the 4 radial modes, leaving 1 = Higgs.

STATUS: [SPECULATION] - The counting works suggestively but
the physics needs rigorous derivation.
""")

# ==============================================================================
# VERIFICATION TESTS
# ==============================================================================

print("="*70)
print("VERIFICATION TESTS")
print("="*70)

tests = []

# Test 1: m_tilt formula
m_tilt_check = 2*sqrt(2)*alpha
tests.append(("m_tilt = 2*sqrt(2)/137 M_Pl", m_tilt_check == 2*sqrt(2)/137))

# Test 2: At CMB, g = 5/6
g_CMB = 1 - Rational(1, 6)
tests.append(("g(phi_CMB) = 5/6", g_CMB == Rational(5, 6)))

# Test 3: Goldstone count = 12
tests.append(("Goldstone modes = n_d*(n_d-1) = 12", n_d*(n_d-1) == 12))

# Test 4: Total modes = n_d^2 = 16
tests.append(("Total modes = n_d^2 = 16", n_d + n_d*(n_d-1) == n_d**2))

# Test 5: SM gauge dim = 12
sm_dim = 8 + 3 + 1  # SU(3) + SU(2) + U(1)
tests.append(("dim(SU(3)xSU(2)xU(1)) = 12", sm_dim == 12))

# Test 6: Goldstone count matches SM gauge dim
tests.append(("Goldstone count = SM gauge dim = 12", n_d*(n_d-1) == sm_dim))

# Test 7: m_tilt >> H_inf
m_sq = 8 * alpha**2  # m_tilt^2 / M_Pl^2
H_sq = alpha**4 / 3   # H_inf^2 / M_Pl^2 (approximate)
tests.append(("m_tilt >> H_inf (ratio > 100)", float(m_sq/H_sq) > 100))

# Test 8: At phi = mu, m_tilt = 0
g_at_mu = 1 - 1  # g(mu) = 1 - mu^2/mu^2 = 0
tests.append(("At phi=mu: g=0, m_tilt=0", g_at_mu == 0))

# Test 9: Massive modes = n_d = 4
tests.append(("Massive modes = n_d = 4", n_d == 4))

# Test 10: Eaten + Higgs = massive modes
# In SM: 3 eaten (W+,W-,Z) + 1 Higgs = 4
tests.append(("Eaten(3) + Higgs(1) = n_d = 4", 3 + 1 == n_d))

print()
all_pass = True
for name, passed in tests:
    status = "PASS" if passed else "FAIL"
    print(f"[{status}] {name}")
    if not passed:
        all_pass = False

print()
if all_pass:
    print(f"ALL {len(tests)} TESTS PASS")
else:
    failed = sum(1 for _, p in tests if not p)
    print(f"{len(tests) - failed}/{len(tests)} TESTS PASS, {failed} FAILED")

# ==============================================================================
# SUMMARY
# ==============================================================================

print("\n" + "="*70)
print("SUMMARY: MASS SPECTRUM FROM TILT POTENTIAL")
print("="*70)

print(f"""
1. TILT MASS: m_tilt = 2*sqrt(2)*alpha*M_Pl ~ 2.5e17 GeV
   - Near GUT/string scale
   - Sub-Planckian by factor 2*sqrt(2)*alpha ~ 0.021
   - Decreases as crystallization proceeds: m(phi) = m_0*sqrt(g(phi))

2. MASS HIERARCHY:
   M_Pl >> mu*M_Pl >> M_crit >> m_tilt >> H_inf
   (Planck >> hilltop >> critical BH >> tilt >> Hubble)

3. GOLDSTONE MODES: n_d*(n_d-1) = 12
   From U(4) -> U(1)^4 symmetry breaking
   = dim(SU(3)xSU(2)xU(1)) = 12 [REMARKABLE]

4. BOSON COUNTING: 16 = 12 + 4
   12 Goldstone (-> gauge bosons?) + 4 massive (-> Higgs sector?)
   If 3 eaten by Higgs mechanism: 12 massless + 3 massive + 1 Higgs

5. phi-DEPENDENT EVOLUTION:
   All masses scale with sqrt(g(phi))
   g(phi_CMB) = 5/6 -> current masses are 96% of pre-crystallization values

CONFIDENCE:
  Mass scales: [DERIVATION] (follow from a, b with framework values)
  Goldstone = gauge: [SPECULATION] (counting matches, physics unclear)
  Higgs counting: [SPECULATION] (suggestive but not derived)
""")
