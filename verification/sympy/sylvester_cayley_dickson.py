#!/usr/bin/env python3
"""
Sylvester-Cayley-Dickson Connection

KEY FINDING: The Cayley-Dickson imaginary dimensions {0,1,3,7} and
Sylvester's sequence {2,3,7,43,...} share the terms {3,7} but are
generated by DIFFERENT recursions:
  CD:  a_{n+1} = 2*a_n + 1  (local doubling)
  Syl: a_{n+1} = a_1*...*a_n + 1  (cumulative product)

They diverge at the Hurwitz boundary: CD gives 15 (sedenions, zero
divisors), Sylvester gives 43 = Phi_6(7) (framework physics). The
divergence encodes the LOSS OF COMPOSITION at dim > 8.

Phi_6 connects them: Phi_6(Im_H) = Im_O, Phi_6(Im_O) = 43. The
cyclotomic polynomial acts as a "bridge" between consecutive division
algebra imaginary dimensions AND beyond.

Status: INVESTIGATION
"""

from sympy import *
from functools import reduce

# Framework constants
Im_R = 0
Im_C = 1
Im_H = 3
Im_O = 7
n_c = 11

def phi6(x):
    """Cyclotomic polynomial Phi_6(x) = x^2 - x + 1"""
    return x**2 - x + 1

tests = []
print("=" * 65)
print("SYLVESTER-CAYLEY-DICKSON CONNECTION")
print("=" * 65)

# ============================================================
# SECTION 1: The two recursions
# ============================================================
print("\n--- Section 1: Two Recursions ---")

# Cayley-Dickson: imaginary dimensions
# Im(R)=0, Im(C)=1, Im(H)=3, Im(O)=7, Im(S)=15, ...
# a_{n+1} = 2*a_n + 1 (from dim doubling: 2^{n+1}-1 = 2*(2^n-1)+1)
cd_imdims = [0]
for i in range(7):
    cd_imdims.append(2 * cd_imdims[-1] + 1)

print("Cayley-Dickson imaginary dimensions (a_{n+1} = 2*a_n + 1):")
names = ["R", "C", "H", "O", "S", "S'", "S''", "S'''"]
for i, (name, val) in enumerate(zip(names, cd_imdims)):
    div_alg = "(division algebra)" if i < 4 else "(zero divisors)"
    print(f"  Im({name}) = {val}  {div_alg}")

# Sylvester's sequence
# a_1=2, a_{n+1} = a_1*...*a_n + 1
syl = [2]
for i in range(6):
    syl.append(reduce(lambda a,b: a*b, syl) + 1)

print(f"\nSylvester's sequence (a_{{n+1}} = prod(a_i) + 1):")
for i, val in enumerate(syl[:7]):
    print(f"  a_{i+1} = {val}")

# ============================================================
# SECTION 2: Where they agree and diverge
# ============================================================
print("\n--- Section 2: Agreement and Divergence ---")

print("Comparison (starting from first non-trivial term):")
print(f"  Position | CD im_dim | Sylvester | Match?")
print(f"  ---------|-----------|-----------|-------")

cd_from_1 = cd_imdims[1:]  # {1, 3, 7, 15, 31, ...}
syl_from_1 = syl[:]         # {2, 3, 7, 43, 1807, ...}

# Direct comparison: they share 3 and 7
shared = set(cd_imdims[:8]) & set(syl[:7])
print(f"\nShared values: {sorted(shared)}")
tests.append(("CD and Sylvester share 3 and 7", {3, 7}.issubset(shared)))

# Divergence point
print(f"\nDivergence at step 4:")
print(f"  CD:       Im(sedenions) = 15 = 2^4 - 1 (has zero divisors)")
print(f"  Sylvester: a_4 = 43 = 2*3*7 + 1 (framework physics)")
print(f"  Ratio: 43/15 = {Rational(43, 15)} = {float(Rational(43,15)):.3f}")
tests.append(("CD step 4 = 15", cd_imdims[4] == 15))
tests.append(("Sylvester step 4 = 43", syl[3] == 43))

# ============================================================
# SECTION 3: Phi_6 as the bridge
# ============================================================
print("\n--- Section 3: Phi_6 Bridges the Sequences ---")

# Phi_6 applied to imaginary dimensions:
print("Phi_6 applied to Cayley-Dickson imaginary dimensions:")
for name, val in [("R", 0), ("C", 1), ("H", 3), ("O", 7)]:
    p = phi6(val)
    print(f"  Phi_6(Im({name})) = Phi_6({val}) = {p}")

tests.append(("Phi_6(0) = 1", phi6(0) == 1))
tests.append(("Phi_6(1) = 1", phi6(1) == 1))
tests.append(("Phi_6(Im_H) = Im_O", phi6(Im_H) == Im_O))
tests.append(("Phi_6(Im_O) = 43", phi6(Im_O) == 43))

# Phi_6 takes each imaginary dimension to the next Sylvester term:
# Phi_6(3) = 7 (Im_H -> Im_O, within division algebras)
# Phi_6(7) = 43 (Im_O -> beyond-Hurwitz)
# Phi_6(43) = 1807 (beyond-Hurwitz -> further beyond)
print(f"\nPhi_6 chain: 3 -> {phi6(3)} -> {phi6(7)} -> {phi6(43)}")
print(f"             Im_H -> Im_O -> 43 -> 1807")
tests.append(("Phi_6(43) = 1807", phi6(43) == 1807))

# Verify Sylvester IS generated by Phi_6 iteration:
print(f"\nSylvester via Phi_6 iteration (starting from 2):")
x = 2
phi6_chain = [x]
for i in range(5):
    x = phi6(x)
    phi6_chain.append(x)
print(f"  Phi_6 chain: {phi6_chain}")
# Note: Phi_6(2) = 4-2+1 = 3, Phi_6(3) = 7, Phi_6(7) = 43, etc.
# This IS Sylvester shifted by one!
print(f"  Sylvester:   {syl[:6]}")

# Check: Phi_6 chain starting from 2 gives Sylvester[1:]
for i in range(5):
    match = phi6_chain[i+1] == syl[i+1]
    if i < 3:
        tests.append((f"Phi_6^{i+1}(2) = Syl[{i+1}] = {syl[i+1]}", match))

# ============================================================
# SECTION 4: WHY they diverge at Hurwitz
# ============================================================
print("\n--- Section 4: Divergence = Hurwitz Boundary ---")

print("""
The two recursions encode different structural information:

Cayley-Dickson: a_{n+1} = 2*a_n + 1
  -> LOCAL operation: "double and add the real line"
  -> Continues indefinitely: sedenions, etc.
  -> Beyond dim 8: LOSES composition (zero divisors appear)

Sylvester: a_{n+1} = a_1 * a_2 * ... * a_n + 1
  -> GLOBAL operation: "remember all previous algebras"
  -> Each step depends on ENTIRE history
  -> The +1 encodes "minimal extension"

At step 4:
  CD gives 2*7+1 = 15 (uses ONLY the previous step)
  Syl gives 2*3*7+1 = 43 (uses ALL previous steps)

The extra factor: 43/15 = (2*3*7+1)/(2*7+1) ~ 2.87
  Sylvester "remembers" the factor of 3 (= Im_H) that CD "forgets"
""")

# The extra factor comes from including a_1*a_2 = 2*3 = 6
# vs just 2 in the CD recursion
cd_4 = 2 * cd_imdims[3] + 1  # 2*7+1 = 15
syl_4 = syl[0] * syl[1] * syl[2] + 1  # 2*3*7+1 = 43
extra = syl_4 - cd_4  # 43 - 15 = 28
print(f"Sylvester - CD at step 4: {syl_4} - {cd_4} = {extra}")
print(f"  28 = N_Goldstone = dim(coset SO(11)/SO(4)xSO(7))")
tests.append(("Syl_4 - CD_4 = 28 = N_Goldstone", extra == 28))

# WOW! The difference is exactly 28!
# 43 - 15 = 28 = the number of Goldstone bosons!
# Is this coincidence or structure?

# Check: 43 - 15 = 2*3*7 + 1 - (2*7+1) = 2*7*(3-1) = 2*7*2 = 28
# = 4*7 = n_d * Im_O = dim(Hom(R^4, R^7))
print(f"\n43 - 15 = 2*3*7+1 - (2*7+1) = 2*7*(3-1) = 4*7 = {4*7}")
print(f"       = n_d * Im_O = dim(coset)")
tests.append(("43-15 = n_d * Im_O = 28",
              syl_4 - cd_4 == 4 * 7))

# Algebraically: prod(a_1..a_n) - 2*a_n
# = a_n*(a_1*...*a_{n-1} - 2)
# At n=3: 7*(2*3-2) = 7*4 = 28

# ============================================================
# SECTION 5: Cayley-Dickson as "local" Phi_6
# ============================================================
print("\n--- Section 5: CD vs Phi_6 Action ---")

# Cayley-Dickson: Im_{n+1} = 2*Im_n + 1
# This is equivalent to: Im_{n+1} = Im_n + (Im_n + 1) = Im_n + dim_n
# where dim_n = Im_n + 1 = 2^n

# Phi_6: a_{n+1} = a_n^2 - a_n + 1
# At a_n = Im_n (where both agree, n=2,3):
# Phi_6(Im_H) = 9 - 3 + 1 = 7 = Im_O = 2*3+1 = 2*Im_H+1 = CD(Im_H) CHECK
# Phi_6(Im_O) = 49 - 7 + 1 = 43 != 2*7+1 = 15 = CD(Im_O)

print("At Im_H = 3:")
print(f"  Phi_6(3) = {phi6(3)} = 7")
print(f"  CD(3)    = {2*3+1} = 7")
print(f"  AGREE: both give Im_O")
tests.append(("Phi_6(Im_H) = CD(Im_H) = Im_O",
              phi6(Im_H) == 2*Im_H+1))

print(f"\nAt Im_O = 7:")
print(f"  Phi_6(7) = {phi6(7)} = 43")
print(f"  CD(7)    = {2*7+1} = 15")
print(f"  DIVERGE: Phi_6 gives 43, CD gives 15")

# WHY do they agree at Im_H?
# Phi_6(x) = x^2 - x + 1, CD(x) = 2x + 1
# Equal when: x^2 - x + 1 = 2x + 1
# -> x^2 - 3x = 0 -> x(x-3) = 0
# -> x = 0 or x = 3

print(f"\nPhi_6(x) = CD(x) when x^2 - 3x = 0, i.e., x = 0 or x = 3")
print(f"So they agree ONLY at x = 0 = Im_R and x = 3 = Im_H")
tests.append(("Agreement only at x=0 and x=3",
              phi6(0) == 2*0+1 and phi6(3) == 2*3+1 and phi6(7) != 2*7+1))

# x = 3 = Im_H is special: it's where CD doubling
# and Phi_6 iteration UNIQUELY agree
# This singles out dim_H = 4 (and hence n_d = 4) as the "branching point"

# ============================================================
# SECTION 6: The branching point is n_d = 4
# ============================================================
print("\n--- Section 6: Branching Point = n_d ---")

# Phi_6(x) = 2x+1 iff x(x-3) = 0
# Non-trivial solution: x = 3 = Im_H = n_d - 1
# So: Im_H = n_d - 1 is the LAST point where both recursions agree
# After that, Phi_6 "pulls away" from CD by keeping cumulative memory

print("The equation Phi_6(x) = 2x+1 has solutions x = 0, 3")
print(f"  x = 3 = Im_H = n_d - 1")
print(f"  -> n_d = 4 marks the branching point between:")
print(f"     LOCAL (CD doubling) and GLOBAL (Sylvester product)")
print(f"  -> Physics follows Sylvester (43 appears), not CD (15 absent)")

# The framework interpretation:
# R^{n_d} is the LAST space where local and global structure agree
# Beyond n_d, you need the full product structure (Sylvester/Phi_6)
# This is related to Hurwitz: division algebras exist for dim <= 8
# and the LAST non-trivial imaginary dimension is Im_O = Phi_6(Im_H) = 7

# ============================================================
# SECTION 7: Representation-theoretic connection attempt
# ============================================================
print("\n--- Section 7: Rep-Theoretic Connection ---")

# Can we prove Phi_6 controls CD growth representation-theoretically?
#
# The CD construction: A -> A+A with multiplication
# (a,b)*(c,d) = (ac-d*b, da+bc*) where * is conjugation
#
# The dimension doubles: dim(A+A) = 2*dim(A)
# So dim = 2^n is entirely from the doubling structure
#
# Phi_6 enters via: Phi_6(Im_A) relates to the norm form
# N(a+b*e) = N(a) + N(b) (Cayley norm)
# The norm form is multiplicative iff A is composition algebra
# -> iff dim <= 8 (Hurwitz)
#
# Phi_6(n) = n^2 - n + 1 counts something about the
# self-interaction of the n-dimensional imaginary part

print("Phi_6(n) = n^2 - n + 1 = dim(End(Im_A)) - n + 1")
for name, n in [("R", 0), ("C", 1), ("H", 3), ("O", 7)]:
    end_im = n * n
    print(f"  A = {name}: End(Im) = {end_im}, Phi_6(Im) = {phi6(n)}")

# n^2 = dim(End(R^n)) = all linear maps on imaginary part
# n = dim(Im_A) = degrees of freedom
# n^2 - n = dim(End(R^n)) - dim(R^n) = "non-diagonal" maps
# n^2 - n + 1 = above + 1 scalar = trace + off-diag + identity
# = dim(End(R^n)_0) + 1 where _0 is traceless part... no

# Actually: n^2-n+1 = C(n,2)*2 - n + 1 + 1 = ... not clean

# Better: n^2 - n + 1 = 1 + n(n-1) = 1 + 2*C(n,2) = 1 + dim(so(n))... no
# n(n-1) = 2*C(n,2) = dim(so(n)) when n >= 2
# So Phi_6(n) = 1 + dim(so(n))? Let's check:
# Phi_6(3) = 7, 1+dim(so(3)) = 1+3 = 4. NO.
# dim(so(n)) = n(n-1)/2, not n(n-1)

# Correct: Phi_6(n) = n^2 - n + 1 = n(n-1) + 1
# n(n-1) = number of ORDERED pairs from n elements (excl. identity)
# This is the number of off-diagonal entries in an n x n matrix

print(f"\nPhi_6(n) = n(n-1) + 1 = off-diagonal entries + 1")
for n in [0, 1, 3, 7]:
    off_diag = n * (n - 1)
    print(f"  n={n}: off-diag = {off_diag}, Phi_6 = {phi6(n)}")

tests.append(("Phi_6(n) = n(n-1)+1 (off-diagonal + scalar)",
              all(phi6(n) == n*(n-1)+1 for n in [0,1,3,7])))

# The "off-diagonal" interpretation:
# For Im(A) = R^n, the space of off-diagonal endomorphisms
# has dimension n(n-1) = n^2-n. Adding the identity gives n^2-n+1.
# This counts: the identity map + all non-identity endomorphisms
# that don't preserve the "diagonal" (identity direction).

# ============================================================
# SECTION 8: The 28 = 43 - 15 coincidence check
# ============================================================
print("\n--- Section 8: Is 43-15=28 Structural? ---")

# 43 - 15 = 28 = n_d * Im_O = dim(coset)
# Algebraically: (2*3*7+1) - (2*7+1) = 2*7*(3-1) = 4*7 = 28
# This factorizes as: Im_O * (2*Im_H - 2) = Im_O * 2*(Im_H-1)
# = Im_O * 2 * (dim_C) = ... hmm
# Actually: 2*(Im_H-1) = 2*2 = 4 = n_d
# So: 43-15 = Im_O * n_d = 7*4 = 28

print("43 - 15 = Im_O * 2*(Im_H-1) = Im_O * n_d = 28")
print(f"  2*(Im_H-1) = 2*{Im_H-1} = {2*(Im_H-1)} = n_d? {2*(Im_H-1) == 4}")
tests.append(("2*(Im_H-1) = n_d", 2*(Im_H-1) == 4))

# Wait: 2*(Im_H - 1) = 2*2 = 4 = n_d.
# This means: Im_H - 1 = n_d/2 = dim_C = 2
# And Im_H = Im_C + dim_C = 1 + 2 = 3. This is Cayley-Dickson!

# So the difference 43-15 = Im_O * n_d is structural:
# It equals the coset dimension BECAUSE of Cayley-Dickson identities.

# Is this deep or shallow? Let me check with general formulas:
# At step n of both sequences (using CD imaginary dim a_n):
# Syl(n) - CD(n) = (a_1*...*a_{n-1} * a_n + 1) - (2*a_n + 1)
#                = a_n * (a_1*...*a_{n-1} - 2)
# At n=3 (the first divergence): a_n = 7, prod(a_1..a_2) = 2*3 = 6
# Difference = 7 * (6-2) = 7*4 = 28

print(f"\nGeneral: Syl_{{n+1}} - CD_{{n+1}} = a_n * (prod(a_1..a_{{n-1}}) - 2)")
print(f"At n=3: 7 * (6-2) = 7*4 = 28")
print(f"  prod(a_1, a_2) - 2 = 2*3 - 2 = 4 = n_d")
print(f"  This is n_d because Im_C*Im_H - dim_C = 1*3 - 2 = 1... NO")
print(f"  Actually: 2*3-2 = dim_C*Im_H - dim_C = dim_C*(Im_H-1) = 2*2 = 4")
tests.append(("prod-2 = dim_C*(Im_H-1) = n_d", 2*3-2 == 4))

# At n=4: a_n = 43, prod(a_1..a_3) = 2*3*7 = 42
# Syl_5 - CD_5 = 43*(42-2) = 43*40 = 1720
# vs 1807 - 87 = 1720. Let me verify:
cd_5 = 2 * 43 + 1
syl_5 = 2*3*7*43 + 1
print(f"\nAt n=4: Syl_5 = {syl_5}, CD_5 = {cd_5}")
print(f"  Difference = {syl_5 - cd_5}")
print(f"  = 43 * (42 - 2) = 43 * 40 = {43*40}")
tests.append(("Syl_5 - CD_5 = 43*40 = 1720", syl_5 - cd_5 == 1720))

# The divergence grows FAST. Only at step 3 does it equal something
# nice (28 = coset dimension). At step 4 it's 1720, not a framework number.
# So 43-15=28 is a ONE-TIME structural coincidence, not a general pattern.

print(f"\nVerdict: 43-15=28 is structural at ONE step (the Hurwitz boundary)")
print(f"but does NOT generalize to higher steps (1720 is not a framework number).")

# ============================================================
# SECTION 9: The deepest connection
# ============================================================
print("\n--- Section 9: Deepest Connection ---")

print("""
The deepest connection between Sylvester and Cayley-Dickson is:

1. Both start from the same seeds: dim_C=2 and Im_H=3
2. Phi_6 generates both:
   - Sylvester IS the Phi_6 iteration (S309 [DERIVATION])
   - CD imaginary dims satisfy Phi_6(Im_n) = Im_{n+1} for n=H only
3. They AGREE precisely where division algebras exist (at 3 and 7)
4. They DIVERGE at the Hurwitz boundary (15 vs 43)
5. The branching equation Phi_6(x) = 2x+1 has unique solution x=3=Im_H
   -> H (quaternions) is the BRANCHING POINT

The structural statement: n_d = 4 = dim_H is special because it's the
LAST algebra where local (CD) and global (Sylvester/Phi_6) agree. This
is equivalent to: H is the last ASSOCIATIVE division algebra.

Confidence: [DERIVATION] for the mathematical facts, [CONJECTURE] for
the physical interpretation (that physics "follows Sylvester not CD").
""")

# Final check: is Phi_6 = 2x+1 at x=3 related to associativity?
# H is associative, O is not. The CD construction at H -> O
# introduces non-associativity. At this SAME step, Phi_6 diverges
# from CD. This suggests Phi_6 "encodes" associativity loss.
# But this is [SPECULATION] -- no proof of this connection.

# ============================================================
# RESULTS
# ============================================================
print("\n" + "=" * 65)
print("TEST RESULTS")
print("=" * 65)

passed = 0
failed = 0
for name, result in tests:
    status = "PASS" if result else "FAIL"
    if result:
        passed += 1
    else:
        failed += 1
    print(f"[{status}] {name}")

print(f"\nTotal: {passed}/{passed+failed} PASS")
