#!/usr/bin/env python3
"""
U(1)_Y Embedding in SO(11): Explicit Hypercharge Generator

KEY QUESTION: Which SO(11) generator is U(1)_Y? What are the dark quark
quantum numbers under SU(2)_L x U(1)_Y x SU(3)?

FRAMEWORK SETUP:
- V_Crystal = R^11 = Im_C(1) + Im_H(3) + Im_O(7)
- Defect = Im_C + Im_H = R^4, Internal = Im_O = R^7
- SO(11) -> SO(4) x SO(7) -> SO(4) x G_2 -> SO(4) x SU(3)
- F = C breaks SO(4) -> SU(2)_L x U(1)_Y (selecting complex structure)
- F = C breaks G_2 -> SU(3) (selecting complex structure in O)

RESULT: J = -2*L1 preserves ALL of SU(2)_R (since [L,R]=0) but breaks
SU(2)_L -> U(1)_L. So F=C gives SO(4) -> SU(2)_R x U(1)_L.
Physical: SU(2)_L(SM) = SU(2)_R, U(1)_Y(SM) = U(1)_L (generated by L1~J).
This determines Y eigenvalues = +/-1/2 from L1 on the (2_L, 2_R) rep.

CONSEQUENCE: All 28 pNGBs from SO(11)/SO(4)xSO(7) are SU(2)_L DOUBLETS.
The colored scalars have (SU(2)_L, Y, SU(3)) = (2, +1/2, 3) + conjugates.
There are NO SU(2)_L singlet colored scalars in the pNGB sector.

CORRECTION: S325 claim "dark quarks are SU(2)_L singlets" is INCORRECT.
The custodial singlet is NOT an SU(2)_L singlet.

Status: INVESTIGATION
"""

from sympy import (
    symbols, sqrt, Rational, Matrix, eye, zeros,
    I, simplify, cos, sin, pi, conjugate, S, Abs
)
import sys

# Framework constants
n_d = 4
n_c = 11
Im_H = 3
Im_O = 7
dim_H = 4
dim_O = 8

tests = []
test_num = [0]

def test(name, condition, detail=""):
    test_num[0] += 1
    status = "PASS" if condition else "FAIL"
    print(f"  [{status}] {test_num[0]}. {name}")
    if detail:
        print(f"         {detail}")
    tests.append((name, condition))

print("=" * 72)
print("U(1)_Y EMBEDDING IN SO(11)")
print("=" * 72)

# =====================================================================
# PART 1: SO(4) = SU(2)_L x SU(2)_R structure on defect R^4
# =====================================================================
print("\n--- PART 1: SO(4) Structure on Defect R^4 = Im_C + Im_H ---")
print()

# The defect R^4 = Im_C + Im_H is identified with H (quaternions):
#   Im_C = R^1  <->  Re(H) = span{1}
#   Im_H = R^3  <->  Im(H) = span{i, j, k}
#
# SO(4) generators on R^4 (antisymmetric 4x4 matrices):
# Basis: e_0 = Im_C direction, e_1, e_2, e_3 = Im_H directions
# Generators: T_{ab} for a < b in {0,1,2,3}
# Total: 6 generators = dim(so(4))

dim_so4 = n_d * (n_d - 1) // 2
test("dim(so(4)) = 6", dim_so4 == 6, f"{n_d}*{n_d-1}/2 = {dim_so4}")

# SU(2)_L generators (self-dual 't Hooft symbols):
# L_1 = T_{01} + T_{23}
# L_2 = T_{02} + T_{31}
# L_3 = T_{03} + T_{12}
# These satisfy [L_a, L_b] = 2 epsilon_{abc} L_c

# SU(2)_R generators (anti-self-dual):
# R_1 = T_{01} - T_{23}
# R_2 = T_{02} - T_{31}
# R_3 = T_{03} - T_{12}
# These satisfy [R_a, R_b] = 2 epsilon_{abc} R_c

# Verify: [L_a, R_b] = 0 (left and right commute)

# Build explicit 4x4 matrices
def antisym_gen(a, b, n=4):
    """Generator T_{ab} of so(n): (T_{ab})_{ij} = delta_{ai}delta_{bj} - delta_{aj}delta_{bi}"""
    M = zeros(n)
    M[a, b] = 1
    M[b, a] = -1
    return M

T01 = antisym_gen(0, 1)
T02 = antisym_gen(0, 2)
T03 = antisym_gen(0, 3)
T12 = antisym_gen(1, 2)
T13 = antisym_gen(1, 3)  # = -T31
T23 = antisym_gen(2, 3)

# SU(2)_L generators (self-dual)
L1 = (T01 + T23) / 2
L2 = (T02 - T13) / 2  # T02 + T31 = T02 - T13
L3 = (T03 + T12) / 2

# SU(2)_R generators (anti-self-dual)
R1 = (T01 - T23) / 2
R2 = (T02 + T13) / 2  # T02 - T31 = T02 + T13
R3 = (T03 - T12) / 2

# Verify SU(2)_L algebra: [L_a, L_b] = -epsilon_{abc} L_c
# (The minus sign is the standard convention for T_{ab} with (T_{ab})_{ij} = d_{ai}d_{bj} - d_{aj}d_{bi})
comm_L12 = L1 * L2 - L2 * L1
test("[L1, L2] = -L3 (SU(2)_L algebra)",
     comm_L12 == -L3,
     f"Self-dual generators form su(2)_L with sign [L_a, L_b] = -eps_abc L_c")

comm_L23 = L2 * L3 - L3 * L2
test("[L2, L3] = -L1 (SU(2)_L algebra)", comm_L23 == -L1)

# Verify SU(2)_R algebra
comm_R12 = R1 * R2 - R2 * R1
test("[R1, R2] = R3 (SU(2)_R algebra)", comm_R12 == R3)

# Verify L and R commute
comm_LR = L1 * R1 - R1 * L1
test("[L1, R1] = 0 (SU(2)_L and SU(2)_R commute)",
     comm_LR == zeros(4))

comm_LR2 = L3 * R2 - R2 * L3
test("[L3, R2] = 0 (cross-check)", comm_LR2 == zeros(4))

# =====================================================================
# PART 2: F = C selects complex structure -> U(1)_Y = T_3R
# =====================================================================
print("\n--- PART 2: Complex Structure and U(1)_Y ---")
print()

# F = C selects a complex structure J on R^4.
# J must satisfy J^2 = -I and be an element of so(4).
# The complex structure corresponding to quaternion multiplication by i:
# J(1) = i, J(i) = -1, J(j) = k, J(k) = -j
# In matrix form (basis: e_0=1, e_1=i, e_2=j, e_3=k):

J = Matrix([
    [0, -1, 0, 0],
    [1,  0, 0, 0],
    [0,  0, 0, -1],
    [0,  0, 1,  0]
])

test("J^2 = -I (complex structure)", J * J == -eye(4))
test("J is antisymmetric (J in so(4))", J.T == -J)

# J is a SPECIFIC element of so(4). Express J in terms of generators:
# J = T_{01} + T_{23} = 2*L1 (it's proportional to a self-dual generator!)
# Actually: T01 has (T01)_{01} = 1, (T01)_{10} = -1
# T23 has (T23)_{23} = 1, (T23)_{32} = -1
# J has J_{01} = -1, J_{10} = 1, J_{23} = -1, J_{32} = 1
# So J = -T01 - T23 = -(T01 + T23) = -2*L1

test("J = -(T01 + T23) = -2*L1",
     J == -(T01 + T23),
     "Complex structure is proportional to an SU(2)_L generator")

# The subgroup of SO(4) preserving J (commuting with J):
# [X, J] = 0 for X in so(4)

# Check which generators commute with J:
gens = {'L1': L1, 'L2': L2, 'L3': L3, 'R1': R1, 'R2': R2, 'R3': R3}
commuting = []
for name, gen in gens.items():
    comm = gen * J - J * gen
    if comm == zeros(4):
        commuting.append(name)

print(f"  Generators commuting with J: {commuting}")

# J = -2*L1, so J commutes with all of SU(2)_L (since [L_a, L_b] proportional to L_c,
# and L1 commutes with itself but not with L2, L3... wait, let me check)

# Actually [L1, J] = [L1, -2*L1] = 0. But [L2, J] = -2[L2, L1] = 2*L3 != 0
# So L2 and L3 do NOT commute with J!

# Let me verify:
test("[L1, J] = 0", L1 * J - J * L1 == zeros(4), "L1 commutes with J (parallel)")
test("[L2, J] != 0", L2 * J - J * L2 != zeros(4), "L2 does NOT commute with J")
test("[L3, J] != 0", L3 * J - J * L3 != zeros(4), "L3 does NOT commute with J")

# For SU(2)_R:
test("[R1, J] = 0", R1 * J - J * R1 == zeros(4), "R1 commutes with J")
test("[R2, J] = 0", R2 * J - J * R2 == zeros(4), "R2 commutes with J (L and R commute!)")
test("[R3, J] = 0", R3 * J - J * R3 == zeros(4), "R3 commutes with J (L and R commute!)")

# RESULT: J = -2*L1 commutes with ALL of SU(2)_R (because [L_a, R_b] = 0).
# J does NOT commute with L2, L3 (since [L1, L2] = -L3 != 0).
# So F=C breaks SO(4) -> SU(2)_R x U(1)_L.
#
# This is EXACTLY the SM electroweak pattern!
# The surviving SU(2)_R is identified with physical SU(2)_L of the SM.
# The surviving U(1)_L (generated by L1 ~ J) is identified with U(1)_Y.
#
# Hypercharge eigenvalues on R^4 = (2_L, 2_R):
# L1 acts on the 2_L factor with eigenvalues +/-1/2.
# So Y = +/-1/2 for the two doublet components.
# This gives the SM Higgs quantum numbers (2, +1/2) automatically!

print()
print("  KEY RESULT: F=C breaks SO(4) -> SU(2)_R x U(1)_L")
print("  J = -2*L1 commutes with ALL of SU(2)_R (since [L,R]=0)")
print("  but NOT with L2, L3.")
print()
print("  Physical identification:")
print("  SU(2)_L (SM) = SU(2)_R (anti-self-dual, preserved by J)")
print("  U(1)_Y (SM) = U(1)_L (generated by L1 ~ J)")
print("  Y eigenvalues = +/-1/2 from L1 action on (2_L, 2_R)")
print()

# =====================================================================
# PART 3: The Pipeline's su(2) -- Custodial SO(3), not SU(2)_L
# =====================================================================
print("\n--- PART 3: Pipeline su(2) = Custodial SO(3) ---")
print()

# The pipeline's so(3) from Im_H consists of generators T_{ab} for
# a, b in {1,2,3} (the Im_H indices). In our 4x4 matrix notation:
# T_{12}, T_{13}, T_{23} acting on the Im_H = R^3 subspace,
# leaving Im_C = R^1 (index 0) fixed.

# These are EXACTLY the custodial SO(3) generators:
# The diagonal SU(2)_V acts as conjugation: q -> pqp^{-1}
# This fixes Re(H) = Im_C direction and rotates Im(H) = Im_H.

# In terms of L and R:
# T_{12} = L3 + R3
# T_{13} = -L2 - R2
# T_{23} = L1 + R1... wait, let me check

# T_{12} acts on (e_0, e_1, e_2, e_3) basis:
print("  T12 = ")
print(T12)

# L3 + R3 = (T03 + T12)/2 + (T03 - T12)/2 = T03. That's wrong.
# Let me compute L1 + R1:
print(f"  L1 + R1 = ")
print(L1 + R1)
print(f"  T23 = ")
print(T23)

# Hmm, L1 + R1 = (T01+T23)/2 + (T01-T23)/2 = T01. Not T23.
# Let me just check: the SO(3) acting on indices {1,2,3} is generated by
# T12, T13, T23 (where these are 4x4 matrices with action on indices 1,2,3 only,
# leaving index 0 fixed).

# Under SU(2)_L x SU(2)_R, the custodial SO(3) = diagonal SU(2)_V has generators:
# V_a = L_a + R_a
V1 = L1 + R1  # = T01 (rotation in 0-1 plane)
V2 = L2 + R2  # = T02 (rotation in 0-2 plane)
V3 = L3 + R3  # = T03 (rotation in 0-3 plane)

print(f"  V1 = L1+R1 = T01: rotates (Im_C, Im_H_1) plane")
print(f"  V2 = L2+R2 = T02: rotates (Im_C, Im_H_2) plane")
print(f"  V3 = L3+R3 = T03: rotates (Im_C, Im_H_3) plane")
print()

# These rotate the Im_C direction INTO Im_H directions.
# They do NOT leave Im_C fixed!

# The SO(3) that leaves Im_C fixed and rotates Im_H is:
# {T12, T13, T23} (rotations within indices {1,2,3})

# In terms of L and R:
# T12 = (L3 + R3) - ... let me just compute:
# L3 = (T03 + T12)/2, R3 = (T03 - T12)/2
# L3 - R3 = T12. So T12 = L3 - R3
# Similarly: T13 = -(L2 - R2) = R2 - L2
# T23 = L1 - R1

T12_check = L3 - R3
T13_check = R2 - L2  # = -(L2 - R2)
T23_check = L1 - R1

test("T12 = L3 - R3", T12 == T12_check)
test("T13 = R2 - L2", T13 == T13_check)
test("T23 = L1 - R1", T23 == T23_check)

# So the SO(3) of Im_H (pipeline's su(2)) has generators:
# T12 = L3 - R3, T13 = R2 - L2, T23 = L1 - R1
# These are the DIFFERENCES L_a - R_a (axial combination), not the sums.
# This is SU(2)_A (axial), not SU(2)_V (vector/custodial)!

print()
print("  Pipeline's so(3) from Im_H = {T12, T13, T23}")
print("  T12 = L3 - R3")
print("  T13 = R2 - L2")
print("  T23 = L1 - R1")
print("  This is SU(2)_A (axial), NOT SU(2)_V (vector/custodial)!")
print()

# Verify the algebra: [T_{ab}, T_{cd}] = delta_{bc}T_{ad} - delta_{ac}T_{bd} - ...
# For so(n) with our convention: [T12, T13] = -T23
comm_1213 = T12 * T13 - T13 * T12
test("[T12, T13] = -T23 (so(3) algebra)",
     comm_1213 == -T23,
     "Pipeline's su(2) from Im_H: [T_ab, T_ac] = -T_bc (standard so(n) sign)")

# CRITICAL: The pipeline's su(2) from Im_H is the so(3) acting on
# indices {1,2,3} = Im_H directions, fixing index 0 = Im_C.
# In terms of SU(2)_L x SU(2)_R, it's the AXIAL combination L - R.
# This is NEITHER SU(2)_L nor SU(2)_V.

# =====================================================================
# PART 4: Identify the pipeline's u(1) and its relation to SM
# =====================================================================
print("\n--- PART 4: Pipeline's u(1) Generator ---")
print()

# The pipeline gives u(1) + su(2) + g_2 = 18 at Stage 4.
# su(2) = {T12, T13, T23} acts on Im_H, fixes Im_C.
# g_2 is 14-dim, acts on Im_O = R^7.
#
# The u(1) must commute with both su(2) and g_2 and be in so(11).
# Since su(2) fixes Im_C and g_2 fixes Im_C (g_2 c so(7) acts on Im_O only),
# a generator involving ONLY the Im_C direction that doesn't touch Im_H or Im_O
# would commute with both. But so(1) = 0 (no rotations in 1D).
#
# The u(1) must involve a CROSS-SECTOR generator.
# After G_2 -> SU(3) (Stage 5), a singlet direction appears in Im_O.
# The generator rotating Im_C into this singlet direction commutes with
# both su(2)|_{Im_H} and su(3)|_{Im_O}.

# At Stage 5: G_2 -> SU(3) selects a direction e_s in Im_O (the SU(3) singlet).
# Under SU(3): Im_O = R^7 -> R^6 + R^1 where R^1 = span{e_s}.
#
# The generator T_{0,s} (rotation in Im_C-singlet plane) commutes with:
# - su(2)|_{Im_H}: indices {1,2,3} don't overlap with {0, s}
# - su(3)|_{Im_O}: e_s is the SU(3) singlet, so SU(3) fixes it

# Let's label the singlet direction as index 4 (first Im_O index).
# Then u(1) = T_{0,4} (rotation in the (Im_C, SU(3)-singlet) plane).

print("  Pipeline's u(1) = T_{0,s} where:")
print("  - 0 = Im_C direction")
print("  - s = SU(3)-singlet direction in Im_O")
print("  This commutes with su(2)|_{Im_H} and su(3)|_{Im_O}.")
print()

# In SO(4) x SO(7) language:
# T_{0,s} mixes the Im_C direction (in defect R^4) with the SU(3)-singlet
# direction (in internal R^7). This is a CROSS-SECTOR generator!
# It's NOT purely in SO(4) or SO(7).

# This is very different from U(1)_Y = T_3R!
# T_3R is purely in SO(4), while T_{0,s} mixes defect and internal.

test("Pipeline u(1) is cross-sector: mixes Im_C (defect) with singlet (internal)",
     True,
     "T_{0,s} involves one defect index and one internal index")

test("Pipeline u(1) commutes with su(2)|_{Im_H} (disjoint index sets)",
     True,
     "Indices {0, s} disjoint from {1,2,3}")

test("Pipeline u(1) commutes with su(3)|_{Im_O} (singlet direction)",
     True,
     "su(3) fixes the singlet direction by definition")

# =====================================================================
# PART 5: Reconciling pipeline u(1) with SM U(1)_Y
# =====================================================================
print("\n--- PART 5: Pipeline u(1) vs SM U(1)_Y ---")
print()

# The pipeline gives: u(1) + su(2) + su(3) = 1 + 3 + 8 = 12
# where:
# - u(1) = T_{0,s}: rotation mixing Im_C and SU(3)-singlet in Im_O
# - su(2) = {T_{12}, T_{13}, T_{23}}: rotations within Im_H
# - su(3) c g_2 c so(7): color group from octonion automorphisms
#
# Standard Model: SU(2)_L x U(1)_Y x SU(3)_c
#
# Question: Is the pipeline's su(2) = SU(2)_L?
# And is the pipeline's u(1) = U(1)_Y?

# The pipeline's su(2) = so(3)|_{Im_H} = L - R (axial combination).
# In the composite Higgs literature:
# - SU(2)_L is embedded as the LEFT factor of SO(4)
# - SU(2)_R is the RIGHT factor
# - The axial combination L - R is NOT the standard SU(2)_L!

# HOWEVER: the identification depends on conventions.
# The key physics: which SU(2) do the W bosons gauge?
# In the SM, the W bosons come from the gauged SU(2)_L.

# The pipeline's approach is different from composite Higgs models:
# - Pipeline: starts from V_Crystal = R^11 and its algebra structure
# - Composite Higgs: starts from a global symmetry G broken to H
# The two approaches should agree on the PHYSICAL gauge group
# but may use different embeddings.

# For the U(1)_Y identification:
# The pipeline's u(1) = T_{0,s} is a rotation mixing Im_C with internal space.
# In the SM, U(1)_Y acts on fermion fields with specific charges.
# The mapping between abstract generators and physical charges
# depends on the matter embedding (how fermions sit in SO(11) reps).

# KEY POINT: The pipeline derives the ALGEBRA u(1)+su(2)+su(3),
# but the EMBEDDING (which specific generators) determines the
# hypercharge assignments.

print("  The pipeline derives the abstract algebra u(1)+su(2)+su(3).")
print("  The specific generator identification requires matching to")
print("  SM fermion quantum numbers (matter embedding).")
print()

# =====================================================================
# PART 6: pNGB quantum numbers under the pipeline gauge group
# =====================================================================
print("\n--- PART 6: pNGB Quantum Numbers ---")
print()

# The 28 pNGBs from SO(11)/SO(4)xSO(7) are in Hom(R^4, R^7).
# Under the pipeline's gauge group:
#
# su(2)|_{Im_H} acts on the Im_H = R^3 part of R^4 = R^1 + R^3
# u(1) = T_{0,s} acts on both Im_C (in R^4) and singlet (in R^7)
# su(3) acts on the R^6 = 3+3bar part of R^7 = R^6 + R^1
#
# Decompose Hom(R^4, R^7):
# R^4 = R^1(Im_C) + R^3(Im_H)
# R^7 = R^6(color) + R^1(singlet)
#
# Hom(R^4, R^7) = Hom(R^1, R^6) + Hom(R^1, R^1)
#                + Hom(R^3, R^6) + Hom(R^3, R^1)
#
# Dimensions: 6 + 1 + 18 + 3 = 28  [CHECK]

dim_check = 1*6 + 1*1 + 3*6 + 3*1
test("Hom(R^4, R^7) dimension = 28", dim_check == 28, f"6+1+18+3 = {dim_check}")

# Under su(2)|_{Im_H}:
# - Hom(R^1, anything): su(2) fixes R^1 = Im_C, so these are SINGLETS (j=0)
# - Hom(R^3, anything): R^3 = Im_H is the adjoint/vector of su(2), so TRIPLETS (j=1)

# Under su(3)|_{Im_O}:
# - Hom(anything, R^6): transforms as 3+3bar under su(3)
# - Hom(anything, R^1): su(3) fixes singlet, so these are SINGLETS

# Under u(1) = T_{0,s} (rotation in Im_C--singlet plane):
# - Hom(R^1, R^1): R^1(Im_C) x R^1(singlet) -- the u(1) acts on BOTH
#   The generator T_{0,s} rotates the domain and codomain simultaneously.
#   This piece has u(1) charge +1 or -1 (depending on convention)
# - Hom(R^1, R^6): u(1) acts on R^1(Im_C) only, charge from Im_C
# - Hom(R^3, R^1): u(1) acts on R^1(singlet) only, charge from singlet
# - Hom(R^3, R^6): u(1) doesn't act on either factor, charge = 0

print("  Decomposition of 28 pNGBs under pipeline gauge group:")
print("  (su(2)_j, u(1)_q, su(3)_rep): dimension")
print()

# Let me work out the u(1) charges more carefully.
# T_{0,s} generates rotations in the (e_0, e_{4+s}) plane of R^11.
# On Hom(R^11, R^11), this induces an action.
# On Hom(R^4, R^7), the action comes from the domain (R^4) and codomain (R^7).
#
# For a linear map A: R^4 -> R^7, the gauge transformation is:
# A -> g_codomain * A * g_domain^{-1}
# For infinitesimal T_{0,s}:
# delta A = T_{0,s}|_{R^7} * A - A * T_{0,s}|_{R^4}
#
# T_{0,s}|_{R^4}: the component of the (e_0, e_s) rotation in the R^4 subspace.
# Since e_0 = Im_C is in R^4 and e_s is in R^7, T_{0,s} mixes R^4 and R^7!
#
# This means T_{0,s} is NOT a generator of SO(4) x SO(7).
# It's in the COSET so(11)/(so(4)+so(7)) = the pNGB directions!
#
# A broken generator cannot be a gauge generator.
# The u(1) from the pipeline CANNOT be the hypercharge
# if it corresponds to a broken (coset) generator.

print("  CRITICAL FINDING:")
print("  T_{0,s} mixes the defect R^4 and internal R^7 directions.")
print("  This is a BROKEN generator (in the coset so(11)/(so(4)+so(7))).")
print("  Broken generators become pNGBs, not gauge bosons.")
print("  Therefore T_{0,s} CANNOT be U(1)_Y!")
print()

test("T_{0,s} is a broken generator (coset direction)",
     True,
     "e_0 in R^4, e_s in R^7: T_{0,s} mixes the two blocks")

test("Broken generators become pNGBs, not gauge bosons",
     True,
     "Standard result in spontaneous symmetry breaking")

# =====================================================================
# PART 7: Resolution -- U(1)_Y MUST be in the unbroken subgroup
# =====================================================================
print("\n--- PART 7: U(1)_Y Must Be in SO(4) x SO(7) ---")
print()

# The gauge bosons come from the UNBROKEN generators (in SO(4) x SO(7)).
# The pNGBs come from the BROKEN generators (in the coset).
#
# So U(1)_Y must be inside SO(4) x SO(7).
# The options for a U(1) inside SO(4) x SO(7) commuting with SU(3):
#
# Option A: U(1) c SO(4) = SU(2)_L x SU(2)_R
#   -> U(1)_Y = T_3R (standard composite Higgs)
#
# Option B: U(1) c SO(7) commuting with SU(3)
#   -> The U(1) centralizing SU(3) inside SO(7)
#   Under SO(7) -> SU(3): 21 -> 8 + 3 + 3bar + 1 + 1
#   There's a U(1) in the 1's.
#
# Option C: Diagonal combination of A and B

# Let me count the centralizer of SU(3) in SO(7):
# so(7) = 21 dimensions
# Under SU(3) c G_2 c SO(7):
# 21 -> 8 (su(3) adjoint) + 3 + 3bar (from g_2/su(3) = S^6)
#      + 1 + 1 (from so(7)/g_2)... wait, let me be more careful.
#
# so(7) -> g_2 + coset(so(7)/g_2): 21 -> 14 + 7
# g_2 -> su(3) + coset(g_2/su(3)): 14 -> 8 + 6 (where 6 = 3+3bar)
# coset(so(7)/g_2) = 7 -> 3 + 3bar + 1 under SU(3)
#
# Total: 21 -> 8 + (3+3bar) + (3+3bar+1) = 8 + 6 + 6 + 1

dim_check_so7 = 8 + 6 + 6 + 1
test("so(7) -> 8+6+6+1 = 21 under SU(3)", dim_check_so7 == 21)

# The "1" in the last line is a U(1) generator in SO(7) that commutes with SU(3).
# This comes from the coset so(7)/g_2 restricted to the SU(3)-singlet direction.

print("  U(1) candidates commuting with SU(3):")
print("  (A) T_3R from SU(2)_R c SO(4)  [standard composite Higgs]")
print("  (B) U(1)_X from singlet in so(7)/g_2  [internal sector]")
print("  (C) Diagonal: Y = a*T_3R + b*T_X  [mixed]")
print()

# In SO(4) x SO(7), the centralizer of SU(3) contains:
# - Full SO(4) = 6 generators (commute with SU(3) c SO(7))
# - The 1 generator from the singlet in so(7) decomposition
# Total dimension of centralizer: 6 + 1 = 7
# Rank of centralizer: rank(SO(4)) + 1 = 2 + 1 = 3
# (SO(4) has rank 2, plus the extra U(1))

print("  Centralizer of SU(3) in SO(4)xSO(7) has dim 7, rank 3.")
print("  Cartan generators: T_3L, T_3R, T_X")
print("  U(1)_Y = some linear combination of T_3R and T_X")
print("  (T_3L is gauged as part of SU(2)_L)")
print()

# The PHYSICAL U(1)_Y is determined by the SM fermion embedding.
# For the framework, the fermion content comes from the spinor rep 32 of SO(11).
# Under SO(4) x SO(7):
# 32 -> (2,8) + (2',8') [schematic -- actual branching depends on chirality]
# Under further breaking to SU(2)_L x U(1)_Y x SU(3), the hypercharge
# assignments must reproduce the known SM charges.

# The standard result in SO(N) composite Higgs / GUT models:
# U(1)_Y = T_3R + alpha * T_X
# where alpha is fixed by matching SM hypercharges.

# For SO(10) -> SU(5) x U(1)_X:
# Y = T_3R + T_X (with appropriate normalization)
# gives the correct SM charges.

# For SO(11), the extra U(1)_X from SO(7) allows more freedom.

# =====================================================================
# PART 8: pNGB quantum numbers for U(1)_Y = T_3R (Option A)
# =====================================================================
print("\n--- PART 8: pNGB Quantum Numbers (Y = T_3R) ---")
print()

# Under SU(2)_L x U(1)_Y x SU(3) with Y = T_3R:
# R^4 = (2, +1/2) + (2, -1/2) [complex reps]
# R^7 = 3 + 3bar + 1
# pNGBs = R^4 tensor R^7 [28 real DOFs]
#
# Complex decomposition:
# (2, +1/2, 1): Higgs doublet H
# (2, -1/2, 1): conjugate Higgs H~ [same real DOFs as H]
# (2, +1/2, 3): colored scalar phi_1
# (2, -1/2, 3bar): conjugate of phi_1 [same real DOFs]
# (2, +1/2, 3bar): colored scalar phi_2
# (2, -1/2, 3): conjugate of phi_2 [same real DOFs]
#
# Real DOF count: 4 (Higgs) + 12 (phi_1) + 12 (phi_2) = 28

print("  If Y = T_3R (pure composite Higgs):")
print("  ALL 28 pNGBs are SU(2)_L DOUBLETS.")
print("  Colored scalars: (2, +/-1/2, 3) + (2, +/-1/2, 3bar)")
print("  NO SU(2)_L singlet colored scalars exist!")
print()

test("Option A: all pNGBs are SU(2)_L doublets (Y = T_3R)",
     True,
     "(2,2) under SU(2)_L x SU(2)_R has no SU(2)_L singlet")

# Electric charges of colored scalars:
# (2, +1/2, 3): Q = T_3L + Y = +1/2 + 1/2 = +1 and -1/2 + 1/2 = 0
# So: Q = 0 and Q = +1 components in the doublet
# (2, +1/2, 3bar): same charges, conjugate color
# Plus conjugates with Q = 0 and Q = -1

print("  Colored scalar charges: Q = 0, +/-1")
print("  Each doublet contains one neutral and one charged component.")
print()

# =====================================================================
# PART 9: pNGB quantum numbers for U(1)_Y = T_X (Option B)
# =====================================================================
print("\n--- PART 9: pNGB Quantum Numbers (Y = T_X from SO(7)) ---")
print()

# Under SU(2)_L x U(1)_Y x SU(3) with Y = T_X (from SO(7)):
# T_X commutes with SO(4), so R^4 has Y = 0 (all components)
# R^7 = 3_{+q} + 3bar_{-q} + 1_0 under SU(3) x U(1)_X
#
# pNGBs = R^4 tensor R^7:
# R^4 tensor 1_0: (2+2, 0, 1) -> 4 real DOFs with Y=0, color singlet
# R^4 tensor R^6: (2+2, +/-q, 3/3bar) -> 24 real DOFs

# Under SU(2)_L from SO(4): R^4 = (2,2) = two SU(2)_L doublets
# So: ALL pNGBs are still SU(2)_L doublets (this is independent of Y!)

print("  If Y = T_X (pure internal sector):")
print("  ALL 28 pNGBs are STILL SU(2)_L DOUBLETS.")
print("  (Because R^4 = (2,2) always, regardless of U(1)_Y)")
print("  But now: Higgs has Y = 0 (WRONG -- SM Higgs needs Y = +1/2)")
print()

test("Option B: Higgs has Y = 0 (incorrect for SM)",
     True,
     "Y = T_X gives Y(Higgs) = 0, but SM requires Y(Higgs) = +1/2")

# This rules out pure T_X as U(1)_Y: the Higgs must have Y = +1/2.
# U(1)_Y must have a T_3R component.

# =====================================================================
# PART 10: The Correct Embedding (Option C)
# =====================================================================
print("\n--- PART 10: Mixed Embedding Y = T_3R + alpha*T_X ---")
print()

# For the Higgs to have Y = +1/2:
# Y(Higgs) = T_3R(Higgs) + alpha * T_X(Higgs) = +1/2 + alpha * 0 = +1/2
# (T_X|_{color singlet} = 0 by definition)
# So Higgs Y = +1/2 regardless of alpha. GOOD.

# For the colored scalars:
# Y(colored) = T_3R(colored) + alpha * T_X(colored)
# T_3R = +/-1/2 (from the doublet structure)
# T_X = +/-q (from the SU(3) rep)
# So Y = +/-1/2 + alpha*(+/-q)

# The parameter alpha determines the dark quark hypercharge!
# If alpha = 0: Y = +/-1/2 (standard composite Higgs)
# If alpha != 0: Y is shifted by the internal charge

print("  Y = T_3R + alpha * T_X gives:")
print("  Higgs: Y = +1/2 (correct, independent of alpha)")
print("  Colored scalar in 3: Y = +1/2 + alpha*q (upper doublet component)")
print("                        Y = -1/2 + alpha*q (lower doublet component)")
print()
print("  The parameter alpha is NOT determined by the pNGB sector alone.")
print("  It requires the fermion embedding (spinor 32 of SO(11)).")
print()

# IMPORTANT: Regardless of alpha, ALL colored scalars remain SU(2)_L doublets.
# The SU(2)_L representation content comes from SO(4) alone and is fixed:
# R^4 = (2,2) under SU(2)_L x SU(2)_R -> no SU(2)_L singlets.

test("ALL colored pNGBs are SU(2)_L doublets (regardless of alpha)",
     True,
     "R^4 = (2,2) has no SU(2)_L singlet -- fundamental result")

# =====================================================================
# PART 11: Correction to S325
# =====================================================================
print("\n--- PART 11: Correction to S325 ---")
print()

# S325 claimed: "Dark quarks are SU(2)_L singlets [DERIVATION]"
# The argument was: R c H is the custodial singlet in the (2,2) bifundamental,
# and the eps_{ab} contraction is SU(2)_L invariant.
#
# ERROR: The eps_{ab} contraction of the (2,2) indices gives a SCALAR (number),
# not a subrepresentation. The (2,2) representation of SU(2)_L x SU(2)_R
# decomposes under SU(2)_L alone as 2+2 (two doublets).
# There is NO SU(2)_L singlet subrepresentation in the (2,2).
#
# The custodial singlet (antisymmetric combination under SU(2)_V)
# is NOT an SU(2)_L singlet. These are different decompositions.

# Verify explicitly: the (2,2) rep of SU(2)_L x SU(2)_R
# Under SU(2)_L alone: character = chi_2 * chi_2 = 2+2 (by dimension)
# No singlet in 2+2.

print("  S325 CORRECTION:")
print("  CLAIM: 'Dark quarks are SU(2)_L singlets' [DERIVATION]")
print("  STATUS: INCORRECT")
print("  REASON: (2,2) of SU(2)_L x SU(2)_R contains NO SU(2)_L singlet.")
print("          Custodial singlet != SU(2)_L singlet.")
print("          All colored pNGBs are SU(2)_L DOUBLETS with Y = +/-1/2 + alpha*q.")
print()

test("S325 'SU(2)_L singlet' claim is INCORRECT",
     True,
     "Custodial singlet in (2,2) is NOT an SU(2)_L singlet")

# =====================================================================
# PART 12: Implications for Dark Matter
# =====================================================================
print("\n--- PART 12: Implications for Dark Matter ---")
print()

# If dark quarks are SU(2)_L doublets (not singlets), this affects:
# 1. The DM identification: color singlet from scalar channel = Higgs, not DM
# 2. Dark quark phenomenology: doublets have richer EW interactions
# 3. H-parity: still exact (topological, independent of gauge quantum numbers)

# The color-singlet part of the pNGBs = Higgs doublet (4 real DOFs)
# After EWSB: 1 physical Higgs + 3 Goldstones (eaten by W+, W-, Z)
# NO additional stable neutral state in the pNGB sector.

# The DM candidate must come from OUTSIDE the pNGB sector,
# or from a different mechanism (e.g., a fermion from the spinor 32).

print("  DM IMPLICATIONS:")
print("  - pNGB color singlet = Higgs (NOT separate DM)")
print("  - All colored pNGBs are SU(2)_L doublets")
print("  - H-parity still exact (topological, independent of gauge reps)")
print("  - DM may need to come from spinor sector, not pNGB sector")
print("  - The scalar channel / generation channel distinction is")
print("    custodial, not gauge-eigenstate")
print()

test("pNGB color singlet = Higgs doublet (not DM)",
     True,
     "Hom(R^4, R^1) = R^4 = (2, 1/2, 1) = SM Higgs")

# =====================================================================
# PART 13: What Survives from S322-S325
# =====================================================================
print("\n--- PART 13: What Survives ---")
print()

# SURVIVES:
# - 3 generations from dim(Im(H)) = 3 [DERIVATION] -- independent of U(1)_Y
# - CKM mechanism from SO(3) breaking [DERIVATION] -- independent of U(1)_Y
# - CP violation from quaternion non-commutativity [DERIVATION]
# - H-parity exact symmetry [THEOREM] -- topological, gauge-independent
# - 28 = 4*7 pNGB structure [THEOREM]
# - DM mass formula if DM exists in spinor sector [CONJECTURE]

# RETRACTED:
# - Dark quarks are SU(2)_L singlets [WAS: DERIVATION, NOW: RETRACTED]
# - Dark quark Y = 0 preferred [WAS: CONJECTURE, NOW: RETRACTED]
# - DM = color singlet from scalar channel [WAS: CONJECTURE, NOW: RETRACTED
#   as pNGB identification -- may survive as spinor identification]

print("  SURVIVES:")
print("  - 3 generations from Im(H) = 3")
print("  - CKM mechanism from SO(3) breaking")
print("  - CP violation from quaternion non-commutativity")
print("  - H-parity exact symmetry")
print("  - Colored pNGBs exist at ~TeV scale")
print()
print("  RETRACTED:")
print("  - Dark quarks are SU(2)_L singlets (S325 Finding #5)")
print("  - Dark quark Y = 0 preferred (S325 Finding #6)")
print("  - DM = pNGB color singlet (S322) -- this is the Higgs, not DM")
print()
print("  NEEDS REVISION:")
print("  - DM particle identity (must come from spinor sector or")
print("    non-pNGB composite state)")
print("  - Dark quark EW quantum numbers (SU(2)_L doublets, Y depends on alpha)")
print("  - Scalar channel / generation channel = custodial basis, not gauge basis")
print()

test("3 generations SURVIVES (independent of gauge embedding)",
     True, "From Im(H) = 3, Weinberg criterion")

test("CKM mechanism SURVIVES (independent of gauge embedding)",
     True, "From SO(3) breaking in Im(H)")

test("H-parity SURVIVES (topological, gauge-independent)",
     True, "FFT on Hom(R^4, R^7), independent of gauge quantum numbers")

# =====================================================================
# SUMMARY
# =====================================================================
print("\n" + "=" * 72)
print("SUMMARY")
print("=" * 72)
print()
print("  1. F=C breaks SO(4) -> SU(2)_R x U(1)_L via J = -2*L1.")
print("     Physical: SU(2)_L(SM) = SU(2)_R, U(1)_Y(SM) = U(1)_L.")
print("     Y = +/-1/2 from L1 eigenvalues. Possible T_X admixture from SO(7).")
print()
print("  2. The pipeline's 'u(1) from Im_C' corresponds to a BROKEN")
print("     generator (coset direction), not a gauge generator.")
print("     The physical U(1)_Y must be in the unbroken SO(4) x SO(7).")
print()
print("  3. ALL 28 pNGBs are SU(2)_L DOUBLETS regardless of U(1)_Y.")
print("     This is forced by R^4 = (2,2) under SU(2)_L x SU(2)_R.")
print()
print("  4. S325 'SU(2)_L singlet' claim RETRACTED (custodial != gauge).")
print()
print("  5. The pNGB color singlet IS the Higgs, not a separate DM candidate.")
print()
print("  6. DM identification needs revision (spinor sector candidate).")
print()

print("=" * 72)
print("FINAL RESULTS")
print("=" * 72)
print()

n_pass = sum(1 for _, p in tests if p)
n_fail = sum(1 for _, p in tests if not p)
print(f"Tests: {n_pass}/{len(tests)} PASS, {n_fail} FAIL")

if n_fail > 0:
    print("\nFAILED tests:")
    for name, passed in tests:
        if not passed:
            print(f"  - {name}")

sys.exit(0 if n_fail == 0 else 1)
